This rule raises an issue when `Thread.sleep()` or `sleep()` is called within a loop where the thread is repeatedly polling to check if a condition has changed.

== Why is this an issue?

Busy waiting with `Thread.sleep()` in loops is an anti-pattern that wastes CPU resources and creates unpredictable timing behavior.

When a thread uses `Thread.sleep()` inside a loop to repeatedly poll for a condition change, it forces the thread to wake up at regular intervals just to check if the condition has changed. This approach has several problems:

* *Resource waste*: The thread consumes CPU cycles unnecessarily by repeatedly waking up and checking conditions
* *Unpredictable timing*: The actual sleep duration may vary depending on system load and thread scheduling
* *Poor responsiveness*: The thread may not respond immediately when the awaited condition becomes true
* *Scalability issues*: Multiple threads doing busy waiting can significantly impact system performance

=== Exceptions

This rule does NOT apply to timing control patterns where `Thread.sleep()` creates intentional delays for legitimate purposes:

* *UI animations and updates*: Fixed-rate timing control for visual effects or periodic UI refreshes
* *Hardware operations*: Timing patterns for GPIO toggling, signal generation, or hardware communication protocols
* *Test orchestration*: Deliberate blocking in tests where the intent is to create delays rather than wait for conditions to change
* *Rate limiting*: Intentional throttling of operations at a fixed rate

The key distinction is the intent: polling for condition changes (problematic) versus creating intentional timing delays (acceptable).

=== What is the potential impact?

Busy waiting can lead to:

* Increased CPU usage and reduced system performance
* Poor application responsiveness
* Scalability problems when multiple threads are involved
* Unpredictable behavior due to timing variations

== How to fix it

Replace busy waiting with `CountDownLatch.await()` for one-time events.

=== Code examples

==== Noncompliant code example

[source,groovy,diff-id=1,diff-type=noncompliant]
----
while (!condition) {
    Thread.sleep(1000) // Noncompliant
}
----

==== Compliant solution

[source,groovy,diff-id=1,diff-type=compliant]
----
CountDownLatch latch = new CountDownLatch(1)
// Signal from another thread: latch.countDown()
latch.await() // Blocks until signaled
----

== Resources

=== Standards

 * CWE-400: Uncontrolled Resource Consumption - https://cwe.mitre.org/data/definitions/400.html[Busy waiting can lead to excessive CPU consumption]
