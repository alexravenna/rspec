<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Calling <code>strlen(ptr + 1)</code> looks very similar to the more common pattern <code>strlen(ptr) + 1</code> and has unclear intent.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The call <code>strlen(ptr) + 1</code> is commonly used to compute the memory required to copy a string:
the <code>+ 1</code> is needed to allocate space for a null-terminator.</p>
</div>
<div class="paragraph">
<p>The very similar call <code>strlen(ptr + 1)</code> that differs only by the placement of the right parenthesis,
produces vastly different results:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>non-empty string computes the length of string without the first character (<code>strlen(ptr) - 1</code>)</p>
</li>
<li>
<p>if the string is empty, it traverses neighboring memory until a null terminator (<code>'\0'</code>) is found.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The latter may lead to undefined behavior.</p>
</div>
<div class="paragraph">
<p>In consequence, calls to <code>strlen(ptr + 1)</code> are likely to be unintended
and the result of a typo. This rule raises issues on such calls.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">size_t size = strlen(ptr + 1); // Noncompliant</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="paragraph">
<p>If the use of <code>strlen(ptr + 1)</code> was an typo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">size_t size = strlen(ptr) + 1; // Compliant</code></pre>
</div>
</div>
<div class="paragraph">
<p>In case when the <code>strlen(ptr + 1)</code> was intentional, to preserve the same behavior, you may increment the pointer before the call.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">char const* next = ptr + 1;
size_t size = strlen(next); // Compliant</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will convey the intent more clearly and avoid any uncertainty regarding the intent.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>If <code>strlen(ptr + 1)</code> is accidentally used instead of <code>strlen(ptr) + 1</code>, it may have a wide range of effects.
For example, it can lead to buffer overflow if the operation was used to compute the required memory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">char* duplicate(char const* source) {
  char* result = (char*)malloc(strlen(source + 1)); // Should be malloc(strlen(source) + 1))
  strcpy(result, source);  // Writes two characters outside of "result" buffer
  return result;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Buffer overflows, as other undefined behavior, have a wide range of effects.
In many cases, the access works by accident and succeeds at writing or reading a value.
However, it can start misbehaving at any time.
If compilation flags, compiler, platform, or runtime environment change,
the same code can crash the application, corrupt memory, or leak a secret.</p>
</div>
</div>
<div class="sect2">
<h3 id="_going_extra_mile">Going extra mile.</h3>
<div class="paragraph">
<p>C&#43;&#43; offers <code>std::string</code>, <code>std::string_view</code> and many other functions simplifying operating on strings.
When possible, higher-level features should be preferred over C-string APIs.</p>
</div>
</div>
</div>
</div>