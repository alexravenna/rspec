This rule raises an issue when a test method does not contain any assertion statements, calls to assertion methods, or use of framework-specific assertion blocks (such as Spock's `then:`, `expect:`, or `where:` blocks). The rule does not apply to disabled tests or tests that delegate to helper methods containing assertions.

== Why is this an issue?

Test methods without assertions are problematic for several reasons:

First, they provide no actual validation of the code being tested. A test that executes code but doesn't verify the results gives a false sense of security - it appears that the code is tested, but no actual verification occurs.

Second, missing assertions often indicate incomplete test implementation. Developers may have written the setup code but forgotten to add the verification logic, leaving the test in an unfinished state.

Third, such tests can hide real issues. If the tested code throws an exception, the test will fail, but if it completes without error, the test passes regardless of whether the behavior is correct.

Finally, tests without assertions make it harder to understand what behavior is being verified, reducing the documentation value of the test suite.

=== Exceptions

The following patterns are considered valid and will not trigger this rule:

* Tests using framework-specific assertion blocks (e.g., Spock's `then:`, `expect:`, or `where:` blocks)
* Tests explicitly marked as disabled (e.g., `@Test(enabled=false)` in TestNG)
* Tests that delegate verification to helper methods that encapsulate assertions

=== What is the potential impact?

Tests without assertions provide no actual verification of code behavior, leading to false confidence in test coverage. This can allow bugs to go undetected and makes it difficult to catch regressions when code changes.

== How to fix it in JUnit

Use JUnit assertion methods to verify expected outcomes.

=== Code examples

==== Noncompliant code example

[source,groovy,diff-id=1,diff-type=noncompliant]
----
@Test
void testUserCreation() { // Noncompliant
    def user = new User("John", "john@example.com")
}
----

==== Compliant solution

[source,groovy,diff-id=1,diff-type=compliant]
----
@Test
void testUserCreation() { // Compliant
    def user = new User("John", "john@example.com")
    assertEquals("John", user.name)
    assertEquals("john@example.com", user.email)
}
----

== How to fix it in Spock

Use Spock's then or expect blocks to define assertions.

=== Code examples

==== Noncompliant code example

[source,groovy,diff-id=2,diff-type=noncompliant]
----
def "should process order"() { // Noncompliant
    given:
    def order = new Order(items: ["item1", "item2"])

    when:
    orderService.process(order)
}
----

==== Compliant solution

[source,groovy,diff-id=2,diff-type=compliant]
----
def "should process order"() { // Compliant
    given:
    def order = new Order(items: ["item1", "item2"])

    when:
    orderService.process(order)

    then:
    order.status == OrderStatus.PROCESSED
    order.processedAt != null
}
----

== Resources

=== Documentation

* JUnit 5 Assertions - https://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions[Official JUnit 5 documentation on writing assertions]

* Spock Framework Assertions - https://spockframework.org/spock/docs/2.3/assertions.html[Spock framework documentation on implicit and explicit assertions]
